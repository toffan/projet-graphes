\documentclass[11pt]{article}

% {{{ Header
\usepackage{fontspec}
\usepackage{polyglossia}
\setdefaultlanguage{french}

%Packages divers
\usepackage[left=35mm, right=35mm]{geometry}
\usepackage{graphicx}
\usepackage{multicol}
\usepackage{caption}


% Formatage des titres
\usepackage{titlesec}
\titleformat{\section}{\Large\bfseries\raggedright}{}{0em}{}[\titlerule]
\titleformat{\subsection}{\large\raggedright}{}{0em}{}[\titlerule]
\titleformat{\subsubsection}{\large\bfseries\raggedright}{}{0em}{}


  % {{{ Environnements mathématique
\usepackage{amsmath}
\newenvironment{system}[1]
  {\left\{\begin{array}{#1}}
  {\end{array}\right.}
  % }}}

  % {{{ Environnements de programmation
\usepackage[outputdir=build]{minted}
  % }}}
% }}}

% {{{ Templates
  % {{{ Figures
% figure classique
% \begin{figure}[!h]
%   \begin{center}
%     \includegraphics[width=\0.7linewidth]{fig/}
%     \caption{}
%   \end{center}
% \end{figure}

% figures cote à cote
% \begin{figure}[!h]
%   \begin{center}
%     \begin{minipage}[b]{0.4\textwidth}
%       \includegraphics[width=\textwidth]{fig/}
%       \caption{}
%     \end{minipage}
%     \hfill
%     \begin{minipage}[b]{0.4\textwidth}
%       \includegraphics[width=\textwidth]{fig/}
%       \caption{}
%     \end{minipage}
%   \end{center}
% \end{figure}

% figure dans un environnement multicol
% \begin{center}
%   \includegraphics[width=0.9\linewidth]{}
%   \captionof{figure}{}
% \end{center}
  % }}}
% }}}


\title{Théorie des graphes\\
Ordonnancement parallèle de tâches sur un graphe orienté acyclique}
\author{Volodia \textsc{Laniel}, Benoit \textsc{Lemarchand}}
\date{\today}

\begin{document}

\begin{titlepage}
  \maketitle
  \vfill
  \tableofcontents
\end{titlepage}

\section{Compréhension et modélisation}
% {{{
  \subsection{Question 1}
    On représente le problème posé sous la forme d'un DAG dans lequel
    \begin{itemize}
      \item les noeuds représentent les opérations de \emph{edge collapse} ou
        \emph{vertex split} de notre maillage.
      \item une opération dépend d'une autre ssi la seconde a modifié des noeuds
        de notre maillage dont la faisabilité de la première opération dépend.
        Plus simplement, une opération ne peut avoir lieu que si la liste des
        noeuds impliqués est à jour.
      % \item les noeuds représentent les noeuds qui existaient, existent ou
      %   existeront dans notre maillage.
      % \item un noeud dépend d'un autre ssi la création ou destruction de ce
      %   premier requière la présence du second. Plus simplement, une opération
      %   ne peut avoir lieu que si la liste des noeuds impliqués est à jour.
    \end{itemize}

  \subsection{Question 2}
    On commence par colorer notre graphe en fonction des coeurs qui effectueront
    les opérations. Le coup en communication pour un noeud en particulier sera
    donc fonction du nombre de noeuds dont dépend celui-ci et qui ne sont pas
    de la même couleur. Ainsi le coup en communication $p_i$ pour un noeud $v_i$
    de couleur $c_i$ et de taille $s_i$ est
    \[ p_i = \sum_{\substack{v_j \in Pred(v_i) \\ c_j \neq c_i}}{s_j} \]

    D'une part, l'équilibrage de charge se traduit par le fait que les couleurs
    de notre graphe sont à peu près équitablement distribuées en nombre, de
    sorte que chaque coeur effectue un travail à peu près similaire. D'autre
    part, pour réduire le coup en communication de notre graphe, on cherchera a
    mettre de la même couleur des sections de graphes fortement liées. Ainsi, un
    coeur ne communiquera pas outre mesure avec les autres coeurs car la plupart
    de ses dépendances ont été traitées par lui-même.

    % TODO (bonus)

  \subsection{Question 3}
    Si un processeur commet une faute mais est immédiatement capable de la
    détecter alors il suffit de rejouer la tâche corrompue. En effet, le
    coeur est en mesure de conserver les paramètres initiaux de la tâche,
    vérifier si celle-ci s'est correctement exécutée puis de la rejouer si
    celle-ci s'avère fausse.

    \begin{center}
      \rule{0.5\linewidth}{0.1mm}

      \emph{On supposera par la suite que la détection d'erreur n'est pas
      immédiate mais ne se produit qu'après la transmission du résultat.}
    \end{center}

    Si un processeur commet une faute alors tous les successeurs de la tâche
    corrompue doivent être recalculés. Cependant, puisque les résultats
    intermédiaires ne sont pas conservés alors l'ensemble des prédécesseurs des
    successeurs de ce noeud doit être traité à nouveau, soit à peu près tout le
    graphe.  Si on nomme $v$ le noeud corrompu, alors l'ensemble des noeuds à
    recalculer est $Pred^{*}(Succ^{*}(v))$.

    Si l'ensemble des résultats sont stockés alors seul l'ensemble des résultats
    potentiellement corrompus est à recalculer, soit $Succ^{*}(v)$ que nous
    allons approximer.
    Soit $n = \#\mathcal{V}$ et $m = \#\mathcal{E}$ alors chaque noeud possède
    en moyenne $\frac{m}{n}$ successeurs.

    % TODO
% }}}
\section{Ordonnancement séquentiel}
% {{{
  \subsection{Question 4}
    Dans le cas d'un ordonnancement séquentiel, l'ensemble des opérations sont
    effectuées par un unique coeur et le graphe est à un unique point en
    mémoire. Ainsi, il n'y a plus de coût de communication, le temps d'exécution
    est donc linéaire en le nombre de tâches à exécuter. De plus, le coeur étant
    seul, il lui suffit d'effectuer les tâches en respectant la chaine de
    dépendances.

  \subsection{Question 5}
    Premièrement, les trois états données forment bien une partition de
    l'ensemble des noeuds, c'est à dire que tout noeud appartient à un unique
    état.

    Notre algorithme nous fait traiter ces trois états de la manière suivante
    \begin{itemize}
      \item \emph{noeud numéroté} \\
        Le noeud appartient à $Z$, son ordre a été défini.
      \item \emph{noeud non numéroté, avec tous ses prédécesseurs numérotés} \\
        Le noeud appartient à $Y$, il est en attente numération.
      \item \emph{noeud non numéroté, avec des prédécesseurs non numérotés} \\
        Le noeud n'est ni dans $Z$, ni dans $Y$, il appartient donc à $X$.
    \end{itemize}

    L'ordre topologique est garanti par le fait qu'un noeud ne sera numéroté ssi
    tous ses prédécesseurs ont été numérotés et ont reçu un numéro inférieur.
    Ainsi, tout noeud du graphe sera supérieur à ses prédécesseurs.

    L'ordre total est garanti par le fait qu'un noeud sera numéroté si tous ses
    prédécesseurs l'on été. On peut ainsi en déduire par induction et parce que
    notre graphe est acyclique que tout noeud sera numéroté.

    La fonction $Succ()$ est appelée une unique fois par noeud dans la boucle
    principale, soit une complexité $\mathcal{O}(c n)$. Or pour chacun de ces
    successeurs, la fonction $Pred()$ est appelée. On approxime la nombre moyen
    de successeurs d'un noeud à $\frac{m}{n}$, d'où un complexité totale de
    $\mathcal{O}(c n \cdot c \frac{m}{n}) = \mathcal{O}(c^2 m)$. Puisque nous
    parlons en notation de Lagrange, la constante $c^2$ pourrait être négligée.

  \subsection{Question 6}
    L'utilisation d'une pile pour $Y$ induit un parcours en profondeur alors que
    l'utilisation d'une file induit un parcours en largeur.

  \subsection{Question 7}
    \begin{minted}{ocaml}
(* code *)
let f = fun x y -> x + y;;
    \end{minted}
% }}}
\section{Ordonnancement parallèle}
% {{{
% }}}
\section{Ordonnancement parallèle sous contrainte}
% {{{
% }}}

\end{document}

% vim: set spelllang=fr:
